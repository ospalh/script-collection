#!/usr/bin/python3
# -*- coding: utf-8 ; mode: python -*-
#
#  © 2017–2022 Roland Sieker <ospalh@gmail.com>
#
# License: GNU AGPL, version 3 or later;
#  http://www.gnu.org/licenses/agpl.html


import argparse
import unicodedata

__version__ = '0.2.0'


def fix_nonbmp_fubar(characters):
    """Fix an encoding-fubar

    Possibly the cygwin-libc mangles non-BMP characters on the command
    line. Here we try to unmangle them.
    """
    fixt_chars = ''
    fbl = b''  # fubard character bytes
    for c in characters:
        o = ord(c)
        if 0xdc00 <= o <= 0xdcff:
            # A bit of fubard character
            fbl += (o & 0xff).to_bytes(1, 'little')
            if len(fbl) >= 4:
                fixt_chars += str(fbl, 'UTF-8')
                fbl = b''
        else:
            fixt_chars += c
            fbl = b''
    return fixt_chars

def uform(character):
    """Return the U+-form of the code point in question

    Return an "U+" and the hex value of the Unicode code point, at
    least four digits
    """
    oc = ord(character)
    return f'U+{oc:04X}'


def name_em(characters):
    """Name unicode characters

    Print the names of each unicode character in characters, together
    with the character itself, and the hexedecimal code point.
    """
    for one_char in characters:
        try:
            uc_name = unicodedata.name(one_char)
        except ValueError as ve:
            uc_name = "({ve})".format(ve=ve)
        print(
            "» {c} «: {n} {u}".format(
                c=one_char, n=uc_name,
                u=uform(one_char)))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="""Print each character, its Unicode name and code \
        point of the argument.""")
    parser.add_argument("characters", type=str, help='''Characters to name''')
    args = parser.parse_args()
    fixt_chars = fix_nonbmp_fubar(args.characters)
    name_em(fixt_chars)
